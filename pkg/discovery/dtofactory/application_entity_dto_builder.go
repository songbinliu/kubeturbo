package dtofactory

import (
	"fmt"
	"github.com/golang/glog"

	api "k8s.io/client-go/pkg/api/v1"

	"github.com/turbonomic/kubeturbo/pkg/discovery/dtofactory/property"
	"github.com/turbonomic/kubeturbo/pkg/discovery/metrics"
	"github.com/turbonomic/kubeturbo/pkg/discovery/util"
	"github.com/turbonomic/kubeturbo/pkg/discovery/vcluster"

	sdkbuilder "github.com/turbonomic/turbo-go-sdk/pkg/builder"
	"github.com/turbonomic/turbo-go-sdk/pkg/proto"
)

/*
*  Application will sell:
        (1) Transactions and ResponseTime(Latency);

   Application will buy:
        (1) VMem, VCPU, and Application(binding it to container)

   //TODO: generate commodities all by vcluster, and get rid of metrics.sink.
   // currently, only Transaction and ResponseTime are generated by vcluster.

*/

var (
	applicationResourceCommodityBought = []metrics.ResourceType{
		metrics.CPU,
		metrics.Memory,
	}
)

type applicationEntityDTOBuilder struct {
	generalBuilder
	vCluster *vcluster.VirtualCluster
}

func NewApplicationEntityDTOBuilder(sink *metrics.EntityMetricSink, vc *vcluster.VirtualCluster) *applicationEntityDTOBuilder {
	return &applicationEntityDTOBuilder{
		generalBuilder: newGeneralBuilder(sink),
		vCluster:       vc,
	}
}

// get hosting node cpu frequency
func (builder *applicationEntityDTOBuilder) getNodeCPUFrequency(pod *api.Pod) (float64, error) {
	key := util.NodeKeyFromPodFunc(pod)
	cpuFrequencyUID := metrics.GenerateEntityStateMetricUID(metrics.NodeType, key, metrics.CpuFrequency)
	cpuFrequencyMetric, err := builder.metricsSink.GetMetric(cpuFrequencyUID)
	if err != nil {
		err := fmt.Errorf("Failed to get cpu frequency from sink for node %s: %v", key, err)
		glog.Error(err)
		return 0.0, err
	}

	cpuFrequency := cpuFrequencyMetric.GetValue().(float64)
	return cpuFrequency, nil
}

func (builder *applicationEntityDTOBuilder) BuildEntityDTOs(pods []*api.Pod) ([]*proto.EntityDTO, error) {
	var result []*proto.EntityDTO

	for _, pod := range pods {
		podFullName := util.GetPodClusterID(pod)
		nodeCPUFrequency, err := builder.getNodeCPUFrequency(pod)
		if err != nil {
			glog.Errorf("failed to build ContainerDTOs for pod[%s]: %v", podFullName, err)
			continue
		}

		vpod, exist := builder.vCluster.Pods[podFullName]
		if !exist {
			err := fmt.Errorf("Potential bug: cannot find pod[%v] from vcluster.", podFullName)
			glog.Errorf(err.Error())
			glog.Errorf("Failed to build EntityDTOs for pod[%v]'s containers.", podFullName)
			//vpod = nil
			continue
		}

		podId := string(pod.UID)
		for i := range pod.Spec.Containers {
			//1. Id and Name
			container := &(pod.Spec.Containers[i])
			containerId := util.ContainerIdFunc(podId, i)
			appId := util.ApplicationIdFunc(containerId)
			displayName := util.ApplicationDisplayName(podFullName, container.Name)

			ebuilder := sdkbuilder.NewEntityDTOBuilder(proto.EntityDTO_APPLICATION, appId).
				DisplayName(displayName)

			//2. sold commodities: transaction & latency
			commoditiesSold, err := builder.getCommoditiesSold(appId, i, vpod)
			if err != nil {
				glog.Errorf("Failed to create Application(%s) entityDTO: %v", displayName, err)
				continue
			}
			ebuilder.SellsCommodities(commoditiesSold)

			//3. bought commodities: vcpu/vmem/application
			commoditiesBought, err := builder.buildBuying(podId, containerId, container.Name, nodeCPUFrequency)
			if err != nil {
				glog.Errorf("Failed to create Application(%s) entityDTO: %v", displayName, err)
				continue
			}
			provider := sdkbuilder.CreateProvider(proto.EntityDTO_CONTAINER, containerId)
			ebuilder.Provider(provider).BuysCommodities(commoditiesBought)

			//4. set properties
			properties := builder.getApplicationProperties(pod, i)
			ebuilder.WithProperties(properties)

			if !util.Monitored(pod) {
				ebuilder.Monitored(false)
			}

			appType := util.GetAppType(pod)
			ebuilder.ApplicationData(&proto.EntityDTO_ApplicationData{
				Type: &appType,
			})

			//5. build the entityDTO
			entityDTO, err := ebuilder.Create()
			if err != nil {
				glog.Errorf("Failed to build Application entityDTO based on application %s: %s", displayName, err)
				continue
			}
			result = append(result, entityDTO)
		}
	}

	return result, nil
}

func (builder *applicationEntityDTOBuilder) getCommoditiesSold(appId string, index int, vpod *vcluster.Pod) ([]*proto.CommodityDTO, error) {
	var result []*proto.CommodityDTO
	usedTrans := float64(0.0)
	usedLatency := float64(0.0)

	// TODO: If container is not the container, should it still sell transactions and latency?
	if index == vpod.MainContainerIdx { // && vpod.Service != nil
		usedTrans = vpod.Transaction.Used
		usedLatency = vpod.Latency.Used
	}

	//1. transaction per second
	ebuilder := sdkbuilder.NewCommodityDTOBuilder(proto.CommodityDTO_TRANSACTION).Key(appId).
		Capacity(vpod.Transaction.Capacity).
		Used(usedTrans)
	tranCommodity, err := ebuilder.Create()
	if err != nil {
		glog.Errorf("Failed to create Transaction commodity for App(%v-%d) for selling: %v", vpod.FullName, index, err)
		return result, err
	}
	result = append(result, tranCommodity)

	//2. latency
	ebuilder2 := sdkbuilder.NewCommodityDTOBuilder(proto.CommodityDTO_RESPONSE_TIME).Key(appId).
		Capacity(vpod.Latency.Capacity).
		Used(usedLatency)
	latencyCommodity, err := ebuilder2.Create()
	if err != nil {
		glog.Errorf("Failed to create Latency commodity for App(%v-%d) for selling: %v", vpod.FullName, index, err)
		return result, err
	}
	result = append(result, latencyCommodity)
	if usedTrans > 0.0 || usedLatency > 0.0 {
		glog.V(2).Infof("App(%v-%d) usedTrans=%.3f, latency=%.3f", vpod.FullName, index, usedTrans, usedLatency)
	}

	return result, nil
}

// Build the bought commodities by each application.
// An application buys vCPU, vMem and Application commodity from a container.
func (builder *applicationEntityDTOBuilder) buildBuying(podId, containerId, containerName string, cpuFreq float64) ([]*proto.CommodityDTO, error) {
	var result []*proto.CommodityDTO

	//1. get the used cpu/memory
	cpuUsed, memUsed, err := builder.getCPUMemoryUsed(podId, containerName, cpuFreq)
	if err != nil {
		glog.Errorf("Failed to get cpu/memory used for application(%v): %v", containerName, err)
		return result, err
	}

	//2. build cpu commodity
	cpuComm := buildBuyComm(cpuUsed, 0.0, proto.CommodityDTO_VCPU)
	if cpuComm == nil {
		glog.Errorf("Failed to build cpu commodity for application(%v)", containerName)
		return result, err
	}
	result = append(result, cpuComm)

	//2. build memory commodity
	memComm := buildBuyComm(memUsed, 0.0, proto.CommodityDTO_VMEM)
	if memComm == nil {
		glog.Errorf("Failed to build memory commodity for application(%v)", containerName)
		return result, err
	}
	result = append(result, memComm)

	//3. build application commodity
	appComm := buildBuyKeyComm(containerId, proto.CommodityDTO_APPLICATION)
	if appComm == nil {
		glog.Errorf("Failed to build app commodity for application(%v)", containerName)
		return result, err
	}
	result = append(result, appComm)

	return result, nil
}

func (builder *applicationEntityDTOBuilder) getUsed(key string, entityType metrics.DiscoveredEntityType, rtype metrics.ResourceType) (float64, error) {
	usedMetricUID := metrics.GenerateEntityResourceMetricUID(entityType, key, rtype, metrics.Used)
	usedMetric, err := builder.metricsSink.GetMetric(usedMetricUID)
	if err != nil {
		glog.Errorf("Failed to get %s used for %s %s: %v", rtype, entityType, key, err)
		return 0, err
	}
	usedValue := usedMetric.GetValue().(float64)

	return usedValue, nil
}

func (builder *applicationEntityDTOBuilder) getCPUMemoryUsed(podId, containerName string, cpuFreq float64) (float64, float64, error) {
	containerId := util.ContainerStatNameFunc(podId, containerName)
	usedId := util.ApplicationIdFunc(containerId)

	cpuUsed, err := builder.getUsed(usedId, metrics.ApplicationType, metrics.CPU)
	if err != nil {
		glog.Errorf("Failed to get used cpu for container: %v, set to 0", usedId)
		cpuUsed = 0
	}
	memUsed, err := builder.getUsed(usedId, metrics.ApplicationType, metrics.Memory)
	if err != nil {
		glog.Errorf("Failed to get used memory for container: %v, set to 0", usedId)
		memUsed = 0
	}

	cpuUsed = cpuUsed * cpuFreq
	return cpuUsed, memUsed, nil
}

// Get the properties of the pod. This includes property related to application cluster property.
func (builder *applicationEntityDTOBuilder) getApplicationProperties(pod *api.Pod, index int) []*proto.EntityDTO_EntityProperty {
	var properties []*proto.EntityDTO_EntityProperty
	// additional node cluster info property.
	appProperties := property.AddHostingPodProperties(pod.Namespace, pod.Name, index)
	properties = append(properties, appProperties...)

	return properties
}
